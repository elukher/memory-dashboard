<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>QA Performance Testing Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
        background: #0a0e27;
        min-height: 100vh;
        color: #ffffff;
        overflow-x: hidden;
      }
      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
            circle at 20% 50%,
            rgba(120, 119, 198, 0.3) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 80% 50%,
            rgba(255, 119, 198, 0.3) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 40% 80%,
            rgba(120, 219, 255, 0.2) 0%,
            transparent 50%
          );
        pointer-events: none;
        z-index: 1;
      }
      .container {
        max-width: 1600px;
        margin: 0 auto;
        padding: 20px;
        position: relative;
        z-index: 2;
      }
      .header {
        text-align: center;
        margin-bottom: 40px;
        animation: slideDown 0.8s ease-out;
      }
      @keyframes slideDown {
        from {
          transform: translateY(-50px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }
      h1 {
        font-size: 3.5em;
        font-weight: 900;
        background: linear-gradient(
          135deg,
          #667eea 0%,
          #f093fb 50%,
          #f5576c 100%
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        margin-bottom: 10px;
        text-transform: uppercase;
        letter-spacing: 2px;
      }
      .subtitle {
        color: rgba(255, 255, 255, 0.7);
        font-size: 1.2em;
        font-weight: 300;
      }
      .status-bar {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 20px;
        margin-bottom: 30px;
        align-items: stretch;
        animation: fadeIn 1s ease-out 0.3s both;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      .status-card {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 20px;
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        min-height: 120px;
      }
      .status-card::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, #667eea, #f093fb);
        animation: shimmer 3s infinite;
      }
      @keyframes shimmer {
        0% {
          transform: translateX(-100%);
        }
        100% {
          transform: translateX(100%);
        }
      }
      .status-card:hover {
        transform: translateY(-5px);
        background: rgba(255, 255, 255, 0.08);
        box-shadow: 0 10px 40px rgba(102, 126, 234, 0.2);
      }
      .status-label {
        font-size: 0.85em;
        color: rgba(255, 255, 255, 0.6);
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 10px;
      }
      .status-value {
        font-size: 2em;
        font-weight: 700;
        color: #fff;
        display: flex;
        align-items: baseline;
        gap: 10px;
        min-height: 1.5em;
      }
      .status-unit {
        font-size: 0.5em;
        color: rgba(255, 255, 255, 0.5);
      }
      .file-upload-section {
        background: rgba(255, 255, 255, 0.03);
        border: 2px dashed rgba(255, 255, 255, 0.1);
        border-radius: 20px;
        padding: 30px;
        margin-bottom: 40px;
        text-align: center;
        transition: all 0.3s ease;
        animation: fadeIn 1s ease-out 0.5s both;
      }
      .file-buttons {
        display: flex;
        gap: 20px;
        justify-content: center;
        margin-top: 20px;
      }
      .file-input-label {
        padding: 15px 30px;
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        border-radius: 15px;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.3s ease;
        display: inline-flex;
        align-items: center;
        gap: 10px;
        box-shadow: 0 5px 20px rgba(102, 126, 234, 0.3);
      }
      input[type="file"] {
        display: none;
      }

      /* ------------------------------ */
      /* üîß ALIGNED DASHBOARD FIX BELOW */
      /* ------------------------------ */
      .memory-charts {
        display: flex;
        align-items: flex-start;
        justify-content: center;
        gap: 30px;
        margin: 40px 0;
      }

      .memory-charts > div {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
      }

      #dashboard1,
      #dashboard2 {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        height: 100%;
      }

      .dashboard-grid {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
      }

      .status-bar {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 20px;
        margin-bottom: 30px;
        align-items: stretch;
      }

      #dashboard1 .chart-container,
      #dashboard2 .chart-container {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        height: 100%;
      }

      .memory-charts .dashboard-grid {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        justify-content: flex-end; /* ensures charts bottom-align */
      }

      /* ------------------------------ */
      /* üîß END ALIGNMENT FIX */
      /* ------------------------------ */

      .chart-container {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 25px;
        position: relative;
        animation: scaleIn 0.8s ease-out;
      }
      @keyframes scaleIn {
        from {
          transform: scale(0.9);
          opacity: 0;
        }
        to {
          transform: scale(1);
          opacity: 1;
        }
      }
      .chart-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }
      .chart-title {
        font-size: 1.3em;
        font-weight: 600;
        color: #fff;
      }
      .chart-badge {
        padding: 5px 15px;
        border-radius: 20px;
        font-size: 0.85em;
        font-weight: 600;
      }
      .badge-memory {
        background: rgba(147, 51, 234, 0.2);
        color: #c084fc;
        border: 1px solid #c084fc;
      }
      .chart-wrapper {
        position: relative;
        height: 450px;
        width: 100%;
      }
      .metrics-summary {
        background: rgba(255, 255, 255, 0.03);
        border-radius: 20px;
        padding: 30px;
        margin: 30px 0;
        position: relative;
        overflow: hidden;
      }
      .metrics-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 25px;
      }
      .metric-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 12px;
      }
      .metric-name {
        font-size: 0.95em;
        color: rgba(255, 255, 255, 0.7);
      }
      .metric-value {
        font-size: 1.1em;
        font-weight: 600;
        color: #fff;
      }
      .export-button {
        position: fixed;
        bottom: 30px;
        right: 30px;
        padding: 15px 30px;
        background: linear-gradient(135deg, #10b981, #059669);
        color: white;
        border: none;
        border-radius: 50px;
        font-size: 1em;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 5px 20px rgba(16, 185, 129, 0.4);
        transition: all 0.3s ease;
        z-index: 1000;
      }
      .export-button:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 25px rgba(16, 185, 129, 0.5);
      }
      .export-button:disabled {
        background: #555;
        cursor: not-allowed;
        opacity: 0.5;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>QA Performance Testing</h1>
        <p class="subtitle">Memory Leak & Health Comparison</p>
      </div>

      <!-- File Upload Section -->
      <div class="file-upload-section">
        <h3 style="margin-bottom: 10px; color: rgba(255, 255, 255, 0.9)">
          üìä Load Test Data
        </h3>
        <p style="color: rgba(255, 255, 255, 0.6); margin-bottom: 20px">
          Upload one or both TSVs to analyze
        </p>
        <div class="file-buttons">
          <label for="memoryFile1" class="file-input-label"
            >üíæ Memory TSV1</label
          >
          <input type="file" id="memoryFile1" accept=".tsv,.csv,.txt" />
          <label for="memoryFile2" class="file-input-label"
            >üíæ Memory TSV2</label
          >
          <input type="file" id="memoryFile2" accept=".tsv,.csv,.txt" />
        </div>
        <div
          id="fileStatus"
          style="margin-top: 15px; color: rgba(255, 255, 255, 0.6)"
        ></div>
      </div>

      <!-- Dashboards side by side -->
      <div class="memory-charts">
        <div id="dashboard1">
          <h2>üìà Memory Dashboard TSV1</h2>
          <div class="status-bar">
            <div class="status-card">
              <div class="status-label">System Health</div>
              <div class="status-value">
                <span id="systemHealth1">--</span
                ><span class="status-unit">%</span>
              </div>
            </div>
            <div class="status-card">
              <div class="status-label">App Health</div>
              <div class="status-value">
                <span id="appHealth1">--</span
                ><span class="status-unit">%</span>
              </div>
            </div>
            <div class="status-card">
              <div class="status-label">Peak Memory</div>
              <div class="status-value">
                <span id="peakMemory1">-- MB</span>
              </div>
            </div>
            <div class="status-card">
              <div class="status-label">Average Memory</div>
              <div class="status-value">
                <span id="averageMemory1">-- MB</span>
              </div>
            </div>
            <div class="status-card">
              <div class="status-label">Memory Growth</div>
              <div class="status-value">
                <span id="memoryGrowth1">--</span>
                <span class="status-unit">MB/min</span>
              </div>
            </div>
            <div class="status-card" id="leakCard1">
              <div class="status-label">Leak Detection</div>
              <div class="status-value">
                <span id="leakStatus1">--</span>
              </div>
            </div>
          </div>
          <div class="dashboard-grid">
            <div class="chart-container">
              <div class="chart-header">
                <h3 class="chart-title">Memory Usage (TSV1)</h3>
                <span class="chart-badge badge-memory">MEMORY</span>
              </div>
              <div class="chart-wrapper">
                <canvas id="memoryLeakChart1"></canvas>
              </div>
            </div>
          </div>
        </div>

        <div id="dashboard2">
          <h2>üìà Memory Dashboard TSV2</h2>
          <div class="status-bar">
            <div class="status-card">
              <div class="status-label">System Health</div>
              <div class="status-value">
                <span id="systemHealth2">--</span
                ><span class="status-unit">%</span>
              </div>
            </div>
            <div class="status-card">
              <div class="status-label">App Health</div>
              <div class="status-value">
                <span id="appHealth2">--</span
                ><span class="status-unit">%</span>
              </div>
            </div>
            <div class="status-card">
              <div class="status-label">Peak Memory</div>
              <div class="status-value">
                <span id="peakMemory2">-- MB</span>
              </div>
            </div>
            <div class="status-card">
              <div class="status-label">Average Memory</div>
              <div class="status-value">
                <span id="averageMemory2">-- MB</span>
              </div>
            </div>
            <div class="status-card">
              <div class="status-label">Memory Growth</div>
              <div class="status-value">
                <span id="memoryGrowth2">--</span>
                <span class="status-unit">MB/min</span>
              </div>
            </div>
            <div class="status-card" id="leakCard2">
              <div class="status-label">Leak Detection</div>
              <div class="status-value">
                <span id="leakStatus2">--</span>
              </div>
            </div>
          </div>
          <div class="dashboard-grid">
            <div class="chart-container">
              <div class="chart-header">
                <h3 class="chart-title">Memory Usage (TSV2)</h3>
                <span class="chart-badge badge-memory">MEMORY</span>
              </div>
              <div class="chart-wrapper">
                <canvas id="memoryLeakChart2"></canvas>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Comparison -->
      <div class="chart-container full-width">
        <div class="chart-header">
          <h3 class="chart-title">Comparison</h3>
          <span class="chart-badge badge-memory">PARALLEL</span>
        </div>
        <div class="chart-wrapper large">
          <canvas id="comparisonChart"></canvas>
        </div>

        <!-- üïπÔ∏è Offset input version (bigger + styled) -->
        <div style="text-align: center; margin-top: 20px; color: #ccc">
          <label for="offsetInput" style="font-weight: 500; margin-right: 8px">
            ‚è± Shift TSV2 by (seconds):
          </label>
          <input
            type="number"
            id="offsetInput"
            value="0"
            step="0.5"
            style="
              width: 110px;
              text-align: center;
              margin: 0 10px;
              padding: 8px 12px;
              border-radius: 10px;
              border: 1px solid rgba(96, 165, 250, 0.4);
              background: rgba(255, 255, 255, 0.08);
              color: #fff;
              font-size: 1em;
              font-weight: 600;
              transition: all 0.2s ease;
            "
          />
          <button
            id="applyOffset"
            style="
              padding: 8px 20px;
              border-radius: 10px;
              border: none;
              background: linear-gradient(135deg, #3b82f6, #6366f1);
              color: white;
              font-weight: 700;
              cursor: pointer;
              font-size: 0.95em;
              transition: 0.2s ease;
            "
          >
            Apply Offset
          </button>
          <span id="offsetValue" style="margin-left: 10px; font-weight: 600"
            >0s</span
          >
        </div>
      </div>

      <button id="exportPdfBtn" class="export-button" disabled>
        üìÑ Export to PDF
      </button>
    </div>

    <script>
      let memoryData1 = null,
        memoryData2 = null,
        charts = {},
        chartBounds = {},
        tsv2Offset = 0;

      document
        .getElementById("memoryFile1")
        .addEventListener("change", (e) => handleMemoryFile(e, 1));
      document
        .getElementById("memoryFile2")
        .addEventListener("change", (e) => handleMemoryFile(e, 2));

      // üîß Utility: find global maximum Y value across both TSVs
      function getGlobalMaxY() {
        const extractMax = (data) => {
          if (!data) return 0;
          const rss =
            data["mem.rss"] ||
            Object.values(data).find((v) => Array.isArray(v)) ||
            [];
          if (!Array.isArray(rss) || rss.length === 0) return 0;

          // ‚úÖ Safe max computation without spread
          let maxVal = 0;
          for (let i = 0; i < rss.length; i++) {
            const val = rss[i]?.value ?? 0;
            if (val > maxVal) maxVal = val;
          }
          return maxVal;
        };

        const max1 = extractMax(memoryData1);
        const max2 = extractMax(memoryData2);
        return Math.ceil(Math.max(max1, max2) / 10) * 10 || 100; // round to nearest 10
      }

      function handleMemoryFile(e, idx) {
        const file = e.target.files[0];
        if (!file) return;
        document.getElementById(
          "fileStatus"
        ).textContent = `Loading ${file.name}...`;
        Papa.parse(file, {
          complete: (results) => {
            if (idx === 1) {
              memoryData1 = processMemoryData(results.data);
              memoryData1.fileName = file.name; // keep actual filename
              updateDashboard(1);
            }
            if (idx === 2) {
              memoryData2 = processMemoryData(results.data);
              memoryData2.fileName = file.name; // keep actual filename
              updateDashboard(2);
            }

            updateComparison();
            syncAllYScales();

            enableExportButton();
            document.getElementById(
              "fileStatus"
            ).textContent = `‚úì Loaded ${file.name}`;
          },
          header: true,
          delimiter: "\t",
          skipEmptyLines: true,
          dynamicTyping: true,
        });
      }

      function processMemoryData(rawData) {
        // Parse new TSV structure with total_rss_mb, total_ram_mb, available_ram_mb
        const processed = rawData
          .map((row) => ({
            timestamp: parseFloat(row["time_seconds"] || 0),
            value: parseFloat(row["total_rss_mb"] || 0),
            totalRam: parseFloat(row["total_ram_mb"] || 0),
            availableRam: parseFloat(row["available_ram_mb"] || 0),
          }))
          .filter((r) => !isNaN(r.value) && !isNaN(r.timestamp));

        // üß† Since only first row has total/available RAM, extract it there
        const sysRow = processed.find(
          (r) =>
            r.totalRam &&
            !isNaN(r.totalRam) &&
            r.totalRam > 0 &&
            r.availableRam &&
            !isNaN(r.availableRam)
        );
        const meta = {
          totalRam: sysRow ? sysRow.totalRam : null,
          availableRam: sysRow ? sysRow.availableRam : null,
        };

        return {
          "mem.rss": processed,
          _meta: meta,
        };
      }

      function updateDashboard(idx) {
        const data = idx === 1 ? memoryData1 : memoryData2;
        if (!data) return;

        // Always pick mem.rss if available, otherwise the first valid array series
        let rssData = Array.isArray(data["mem.rss"])
          ? data["mem.rss"]
          : Object.values(data).find((v) => Array.isArray(v)) || [];

        // ‚úÖ Prevent recursion/stack overflow if rssData is not array
        if (!Array.isArray(rssData)) {
          console.error("‚ùå rssData is not an array:", rssData);
          return;
        }

        rssData = rssData.slice().sort((a, b) => a.timestamp - b.timestamp);

        if (!rssData.length) return;

        console.log(
          `Dashboard ${idx} ‚Üí First:`,
          rssData[0],
          `Last:`,
          rssData[rssData.length - 1]
        );

        // Filter out initial transient values
        // ‚úÖ Safely compute peak value without spreading large arrays
        let peak = -Infinity;
        for (const d of rssData) {
          const val = parseFloat(d.value);
          if (!isNaN(val) && val > peak) peak = val;
        }

        // Fallback if all invalid
        if (!isFinite(peak) || peak <= 0) {
          console.warn("‚ö†Ô∏è No valid memory values in dataset");
          peak = 0;
        }

        const meaningful = rssData.filter((d) => d.value > peak * 0.4);
        const values = meaningful.map((d) => d.value);
        const avg = values.reduce((a, b) => a + b, 0) / values.length;

        // Extract MemTotal & MemAvailable from TSV metadata
        let memTotal = data["_meta"]?.totalRam || null;
        let memAvailable = data["_meta"]?.availableRam || null;

        // App & System Health
        // ‚úÖ Improved App Health: based on stability & growth, not total system RAM
        let appHealth = null;
        if (avg && peak && peak > 0) {
          // ratio of how stable memory usage is across the test
          const usageRatio = avg / peak;

          // extract growth rate from memoryGrowth card if not yet available
          let growthRate =
            parseFloat(
              document.getElementById(`memoryGrowth${idx}`).textContent
            ) || 0;

          // ‚úÖ New formula: penalize only positive growth
          const growthPenalty =
            growthRate > 0 ? growthRate * 10 : growthRate * 2; // small bonus if freeing
          appHealth = 100 - (usageRatio * 40 + growthPenalty);

          // clamp between 0‚Äì100
          appHealth = Math.max(0, Math.min(appHealth, 100));
        }

        let systemHealth = null;
        if (memTotal && memAvailable != null && memTotal > 0) {
          systemHealth = (memAvailable / memTotal) * 100;
          systemHealth = Math.max(0, Math.min(systemHealth, 100));
        }

        // Update DOM
        document.getElementById(
          `peakMemory${idx}`
        ).textContent = `${peak.toFixed(1)} MB`;
        document.getElementById(
          `averageMemory${idx}`
        ).textContent = `${avg.toFixed(1)} MB`;

        // ‚úÖ Leak detection (once)
        const leakAnalysis = detectMemoryLeak(rssData);

        // Create chart first
        createMemoryLeakChart(idx, rssData);

        // Leak detection visual
        const leakEl = document.getElementById(`leakStatus${idx}`);
        const leakCard = document.getElementById(`leakCard${idx}`);

        switch (leakAnalysis.status) {
          case "LEAK_DETECTED":
            leakEl.innerHTML = `<span style="color:#ef4444;font-weight:bold;">LEAK (${leakAnalysis.confidence.toFixed(
              0
            )}%)</span>`;
            leakCard.style.background = "rgba(239,68,68,0.2)";
            leakCard.style.border = "2px solid #ef4444";
            leakCard.style.animation = "pulseRed 2s infinite";
            break;

          case "POSSIBLE_LEAK":
            leakEl.innerHTML = `<span style="color:#f59e0b;">‚ö†Ô∏è POSSIBLE (${leakAnalysis.confidence.toFixed(
              0
            )}%)</span>`;
            leakCard.style.background = "rgba(245,158,11,0.15)";
            leakCard.style.border = "1px solid #f59e0b";
            break;

          case "GROWTH_DETECTED":
            leakEl.innerHTML = `<span style="color:#60a5fa;">üìà GROWTH</span>`;
            leakCard.style.background = "rgba(96,165,250,0.1)";
            leakCard.style.border = "1px solid #60a5fa";
            break;

          case "STABLE":
            leakEl.innerHTML = `<span style="color:#10b981;">‚úÖ STABLE</span>`;
            leakCard.style.background = "rgba(16,185,129,0.1)";
            leakCard.style.border = "1px solid #10b981";
            break;
        }

        // Update health visuals
        const appEl = document.getElementById(`appHealth${idx}`);
        const appCard = appEl.closest(".status-card");
        if (appHealth !== null) {
          appEl.textContent = appHealth.toFixed(0);
          colorizeCard(appCard, appHealth);
        } else {
          resetCard(appEl, appCard);
        }

        const sysEl = document.getElementById(`systemHealth${idx}`);
        const sysCard = sysEl.closest(".status-card");
        if (systemHealth !== null) {
          sysEl.textContent = systemHealth.toFixed(0);
          colorizeCard(sysCard, systemHealth);
        } else {
          resetCard(sysEl, sysCard);
        }

        const title = document.querySelector(`#dashboard${idx} .chart-title`);
        if (title) title.textContent = data.fileName || `TSV${idx}`;

        requestAnimationFrame(alignDashboards);
      }

      function colorizeCard(cardEl, value) {
        if (value >= 70) {
          cardEl.style.background = "rgba(34,197,94,0.15)";
          cardEl.style.border = "1px solid rgba(34,197,94,0.4)";
        } else if (value >= 40) {
          cardEl.style.background = "rgba(250,204,21,0.15)";
          cardEl.style.border = "1px solid rgba(250,204,21,0.4)";
        } else {
          cardEl.style.background = "rgba(248,113,113,0.15)";
          cardEl.style.border = "1px solid rgba(248,113,113,0.4)";
        }
      }

      function resetCard(el, cardEl) {
        el.textContent = "N/A";
        el.style.color = "#ccc";
        cardEl.style.background = "rgba(255,255,255,0.05)";
        cardEl.style.border = "1px solid rgba(255,255,255,0.1)";
      }

      function createMemoryLeakChart(idx, rssData) {
        const ctx = document.getElementById(`memoryLeakChart${idx}`);
        if (!ctx) return;
        const sortedData = rssData
          .slice()
          .sort((a, b) => a.timestamp - b.timestamp);

        // Instead of: const peakValue = Math.max(...sortedData.map((d) => d.value));
        const peakValue = sortedData.reduce(
          (max, d) => (d.value > max ? d.value : max),
          -Infinity
        );

        // Filter out values less than 40% of peak (this removes initial small values)
        const meaningfulData = sortedData.filter(
          (d) => d.value > peakValue * 0.4
        );

        if (meaningfulData.length > 1) {
          const first = meaningfulData[0];
          const last = meaningfulData[meaningfulData.length - 1];

          // Calculate growth
          const durationMinutes = (last.timestamp - first.timestamp) / 60;
          let growthRate = 0;
          if (durationMinutes > 0) {
            growthRate = (last.value - first.value) / durationMinutes;
          }

          console.log(`Dashboard ${idx} Calculation:`, {
            peak: peakValue.toFixed(2),
            threshold: (peakValue * 0.4).toFixed(2),
            first: first.value.toFixed(2),
            last: last.value.toFixed(2),
            growth: growthRate.toFixed(2) + " MB/min",
          });

          // Update UI
          const growthEl = document.getElementById(`memoryGrowth${idx}`);
          growthEl.textContent = growthRate.toFixed(2);

          const growthCard = growthEl.closest(".status-card");

          // Negative growth is good - memory being freed
          if (growthRate < 0) {
            growthCard.style.background = "rgba(34,197,94,0.15)"; // green
            growthCard.style.border = "1px solid rgba(34,197,94,0.4)";
          }
          // Small positive growth < 0.5 MB/min is acceptable
          else if (growthRate < 0.5) {
            growthCard.style.background = "rgba(34,197,94,0.15)"; // green
            growthCard.style.border = "1px solid rgba(34,197,94,0.4)";
          }
          // Moderate growth 0.5-2 MB/min needs attention
          else if (growthRate < 2) {
            growthCard.style.background = "rgba(250,204,21,0.15)"; // yellow
            growthCard.style.border = "1px solid rgba(250,204,21,0.4)";
          }
          // High growth > 2 MB/min is concerning
          else {
            growthCard.style.background = "rgba(248,113,113,0.15)"; // red
            growthCard.style.border = "1px solid rgba(248,113,113,0.4)";
          }
        }

        // Create chart as normal
        if (charts[`memoryLeak${idx}`]) charts[`memoryLeak${idx}`].destroy();
        charts[`memoryLeak${idx}`] = new Chart(ctx, {
          type: "line",
          data: {
            datasets: [
              {
                label: `${
                  (idx === 1 ? memoryData1?.fileName : memoryData2?.fileName) ||
                  "TSV" + idx
                }`,
                data: sortedData.map((d) => ({ x: d.timestamp, y: d.value })),
                borderColor: idx === 1 ? "#c084fc" : "#60a5fa",
                backgroundColor:
                  idx === 1
                    ? "rgba(192,132,252,0.25)"
                    : "rgba(96,165,250,0.25)",
                fill: true,
                tension: 0.1,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { labels: { color: "#ddd" } },
              tooltip: {
                callbacks: {
                  label: (ctx) =>
                    `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(2)} MB`,
                  title: (ctx) => `Time: ${ctx[0].parsed.x.toFixed(1)}s`,
                },
              },
            },
            scales: {
              x: {
                type: "linear",
                title: { display: true, text: "Time (s)", color: "#ccc" },
                grid: { color: "rgba(255,255,255,0.08)" },
                ticks: { color: "#ccc" },
              },
              y: {
                min: 0,
                max: getGlobalMaxY(), // üî• dynamically shared max value
                title: { display: true, text: "Memory (MB)", color: "#ccc" },
                grid: { color: "rgba(255,255,255,0.08)" },
                ticks: { color: "#ccc" },
              },
            },
          },
        });
      }
      function calculateGrowthRate(idx) {
        const bounds = chartBounds[idx];
        if (!bounds) return 0;

        const { first, last } = bounds;
        const durationMinutes = (last.timestamp - first.timestamp) / 60;
        if (durationMinutes <= 0) return 0;

        return (last.value - first.value) / durationMinutes;
      }

      function updateComparison() {
        if (!memoryData1 && !memoryData2) return;
        const ctx = document.getElementById("comparisonChart");
        if (!ctx) return;

        const rssData1 = memoryData1
          ? (memoryData1["mem.rss"] || Object.values(memoryData1)[0] || [])
              .slice()
              .sort((a, b) => a.timestamp - b.timestamp)
          : [];
        const rssData2 = memoryData2
          ? (memoryData2["mem.rss"] || Object.values(memoryData2)[0] || [])
              .slice()
              .sort((a, b) => a.timestamp - b.timestamp)
          : [];

        const series1 = rssData1.map((d) => ({ x: d.timestamp, y: d.value }));
        const series2 = rssData2.map((d) => ({
          x: d.timestamp + tsv2Offset,
          y: d.value,
        }));

        // ‚úÖ Use same Y max as individual charts
        const maxY = getGlobalMaxY();

        if (charts.comparison) charts.comparison.destroy();
        charts.comparison = new Chart(ctx, {
          type: "line",
          data: {
            datasets: [
              {
                label: memoryData1?.fileName || "TSV1",
                data: series1,
                borderColor: "#c084fc", // purple
                borderWidth: 2,
                fill: false,
                pointRadius: 0,
                tension: 0.3,
              },
              {
                label: memoryData2?.fileName || "TSV2",
                data: series2,
                borderColor: "#60a5fa", // blue
                borderWidth: 2,
                fill: false,
                pointRadius: 0,
                tension: 0.3,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { labels: { color: "#ddd" } },
              tooltip: {
                callbacks: {
                  label: (context) =>
                    `${context.dataset.label}: ${context.parsed.y.toFixed(
                      2
                    )} MB`,
                  title: (context) =>
                    "Time: " + context[0].parsed.x.toFixed(1) + "s",
                },
              },
            },
            scales: {
              x: {
                type: "linear",
                title: { display: true, text: "Time (s)", color: "#ccc" },
                grid: { color: "rgba(255,255,255,0.1)" },
                ticks: { color: "#ccc" },
              },
              y: {
                min: 0,
                max: maxY, // üî• unified scale with other charts
                title: { display: true, text: "Memory (MB)", color: "#ccc" },
                grid: { color: "rgba(255,255,255,0.1)" },
                ticks: { color: "#ccc" },
              },
            },
          },
        });
      }

      /* kept, but no longer used (you asked to drop Trend) */
      function calculateTrendLine(data) {
        if (!data.length) return [];
        const xs = data.map((p) => p.timestamp),
          ys = data.map((p) => p.value);
        const xMean = xs.reduce((a, b) => a + b, 0) / xs.length,
          yMean = ys.reduce((a, b) => a + b, 0) / ys.length;
        const slope =
          xs
            .map((x, i) => (x - xMean) * (ys[i] - yMean))
            .reduce((a, b) => a + b, 0) /
          xs.map((x) => (x - xMean) ** 2).reduce((a, b) => a + b, 0);
        const intercept = yMean - slope * xMean;
        return [
          { x: xs[0], y: slope * xs[0] + intercept },
          { x: xs[xs.length - 1], y: slope * xs[xs.length - 1] + intercept },
        ];
      }

      function detectMemoryLeak(data) {
        if (!data || data.length < 2)
          return { status: "UNKNOWN", confidence: 0, growth: "N/A" };

        // üß† 1. Filter like the chart does (ignore initial low memory values)
        // üß† Safely compute peak without spread or recursion
        let peak = -Infinity;
        for (const d of data) {
          const val = parseFloat(d.value);
          if (!isNaN(val) && val > peak) peak = val;
        }
        if (!isFinite(peak) || peak <= 0) {
          console.warn("‚ö†Ô∏è detectMemoryLeak(): No valid memory values found");
          peak = 0;
        }

        const meaningfulData = data.filter((d) => d.value > peak * 0.4);

        // üß† 2. Fallback: if filtered data too short, use full dataset
        const usedData = meaningfulData.length > 1 ? meaningfulData : data;

        const first = usedData[0].value;
        const last = usedData[usedData.length - 1].value;
        const durationMin =
          (usedData[usedData.length - 1].timestamp - usedData[0].timestamp) /
          60;

        if (durationMin <= 0)
          return { status: "UNKNOWN", confidence: 0, growth: "N/A" };

        const growthRate = (last - first) / durationMin; // MB/min

        // üßÆ 3. Status thresholds
        let status = "STABLE";
        if (growthRate <= 0) {
          status = "STABLE"; // memory is freeing, no leak
        } else if (growthRate > 5) {
          status = "LEAK_DETECTED";
        } else if (growthRate > 3) {
          status = "POSSIBLE_LEAK";
        } else if (growthRate > 1) {
          status = "GROWTH_DETECTED";
        } else {
          status = "STABLE";
        }

        // üß© 4. Return safe structured object
        return {
          status,
          growth: `${growthRate.toFixed(2)} MB/min`,
          confidence: Math.min(100, Math.abs(growthRate) * 10),
        };
      }

      function normalizeTimestamps(data) {
        if (!data.length) return [];
        const minTs = Math.min(...data.map((d) => d.timestamp));
        return data.map((d) => ({ ...d, timestamp: d.timestamp - minTs }));
      }

      // Enable export button when data is loaded
      function enableExportButton() {
        const btn = document.getElementById("exportPdfBtn");
        if (memoryData1 || memoryData2) {
          btn.disabled = false;
        }
      }

      // Call this function at the end of handleMemoryFile after updateComparison()
      // Add this line: enableExportButton();

      async function exportToPDF() {
        const btn = document.getElementById("exportPdfBtn");
        btn.disabled = true;
        btn.textContent = "‚è≥ Generating PDF...";

        try {
          const { jsPDF } = window.jspdf;
          const pdf = new jsPDF("p", "mm", "a4");
          let yPos = 20;

          // Title
          pdf.setFontSize(20);
          pdf.setTextColor(102, 126, 234);
          pdf.text("QA Performance Testing Report", 105, yPos, {
            align: "center",
          });
          yPos += 15;

          // Add TSV1 data if available
          if (memoryData1) {
            await addDashboardToPDF(pdf, 1, yPos);
            yPos += 100;
          }

          // Add TSV2 data if available (new page if both exist)
          if (memoryData2) {
            if (memoryData1) pdf.addPage();
            await addDashboardToPDF(pdf, 2, memoryData1 ? 20 : yPos);
          }

          // Add comparison chart if both exist
          if (memoryData1 && memoryData2) {
            pdf.addPage();
            pdf.setFontSize(16);
            pdf.text("Memory Comparison", 105, 20, { align: "center" });
            const compChart = document.getElementById("comparisonChart");
            const compImg = compChart.toDataURL("image/png");
            pdf.addImage(compImg, "PNG", 15, 30, 180, 100);
          }

          // Save PDF
          const timestamp = new Date()
            .toISOString()
            .slice(0, 19)
            .replace(/:/g, "-");
          pdf.save(`QA-Performance-Report-${timestamp}.pdf`);

          btn.textContent = "‚úì PDF Exported!";
          setTimeout(() => {
            btn.textContent = "üìÑ Export to PDF";
            btn.disabled = false;
          }, 2000);
        } catch (error) {
          console.error("PDF generation error:", error);
          btn.textContent = "‚ùå Export Failed";
          setTimeout(() => {
            btn.textContent = "üìÑ Export to PDF";
            btn.disabled = false;
          }, 2000);
        }
      }

      async function addDashboardToPDF(pdf, idx, startY) {
        const data = idx === 1 ? memoryData1 : memoryData2;

        pdf.setFontSize(14);
        pdf.setTextColor(0, 0, 0);
        pdf.text(
          `Dashboard ${idx}: ${data.fileName || "TSV" + idx}`,
          15,
          startY
        );

        // Add metrics
        pdf.setFontSize(10);
        let y = startY + 10;

        const metrics = [
          [
            "System Health",
            document.getElementById(`systemHealth${idx}`).textContent + "%",
          ],
          [
            "App Health",
            document.getElementById(`appHealth${idx}`).textContent + "%",
          ],
          [
            "Peak Memory",
            document.getElementById(`peakMemory${idx}`).textContent,
          ],
          [
            "Average Memory",
            document.getElementById(`averageMemory${idx}`).textContent,
          ],
          [
            "Memory Growth",
            document.getElementById(`memoryGrowth${idx}`).textContent +
              " MB/min",
          ],
          [
            "Leak Status",
            document.getElementById(`leakStatus${idx}`).textContent,
          ],
        ];

        metrics.forEach(([label, value]) => {
          pdf.text(`${label}: ${value}`, 15, y);
          y += 7;
        });

        // Add chart image
        const chart = document.getElementById(`memoryLeakChart${idx}`);
        const imgData = chart.toDataURL("image/png");
        pdf.addImage(imgData, "PNG", 15, y + 5, 180, 100);
      }

      function alignDashboards() {
        const sb1 = document.querySelector("#dashboard1 .status-bar");
        const sb2 = document.querySelector("#dashboard2 .status-bar");
        if (!sb1 || !sb2) return;

        // reset before measuring (important if content changed)
        sb1.style.minHeight = "";
        sb2.style.minHeight = "";

        const h1 = sb1.getBoundingClientRect().height;
        const h2 = sb2.getBoundingClientRect().height;
        const max = Math.max(h1, h2);

        sb1.style.minHeight = max + "px";
        sb2.style.minHeight = max + "px";
      }

      // Add event listener
      document
        .getElementById("exportPdfBtn")
        .addEventListener("click", exportToPDF);

      // Run once on load and again if window resizes
      window.addEventListener("load", alignDashboards);
      window.addEventListener("resize", alignDashboards);

      // üîß Manual offset control
      const offsetInput = document.getElementById("offsetInput");
      const offsetValue = document.getElementById("offsetValue");
      const applyOffsetBtn = document.getElementById("applyOffset");

      function updateOffset(newValue) {
        tsv2Offset = parseFloat(newValue) || 0;
        offsetInput.value = tsv2Offset;
        offsetValue.textContent = `${tsv2Offset}s`;
        updateComparison();
      }

      applyOffsetBtn.addEventListener("click", () => {
        const inputVal = parseFloat(offsetInput.value);
        updateOffset(inputVal);
      });

      function syncAllYScales() {
        const maxY = getGlobalMaxY();
        Object.keys(charts).forEach((key) => {
          const chart = charts[key];
          if (chart && chart.options?.scales?.y) {
            chart.options.scales.y.max = maxY;
            chart.update();
          }
        });
      }
    </script>
  </body>
</html>
